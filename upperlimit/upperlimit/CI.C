#ifndef __CINT__
#include "RooGlobalFunc.h"
#endif

#include "RooAbsPdf.h"
#include "RooAddPdf.h"
#include "RooCBShape.h"
#include "RooChebychev.h"
#include "RooConstVar.h"
#include "RooDataSet.h"
#include "RooFitResult.h"
#include "RooGaussian.h"
#include "RooGenericPdf.h"
#include "RooHist.h"
#include "RooHistPdf.h"
#include "RooDataHist.h"
#include "RooKeysPdf.h"
#include "RooProdPdf.h"
#include "RooMCStudy.h"
#include "RooPolynomial.h"
#include "RooRealVar.h"
#include "RooPlot.h"
#include "RooWorkspace.h"
#include "RooChi2Var.h"
#include "RooStats/ModelConfig.h"
#include "RooStats/ProfileLikelihoodCalculator.h"
#include "RooStats/LikelihoodInterval.h"
#include "RooStats/LikelihoodIntervalPlot.h"
#include "RooStats/ToyMCSampler.h"
#include "RooStats/FeldmanCousins.h"
#include "RooStats/ProfileLikelihoodTestStat.h"

// Root stuff
#include "TROOT.h"
#include "TAxis.h"
#include "TCanvas.h"
#include "TDirectory.h"
#include "TFile.h"
#include "TLatex.h"
#include "TSystem.h"
#include "TMath.h"
#include "TPaveLabel.h"
#include "TPaveText.h"
#include "TStyle.h"
#include "TText.h"

#include <fstream>
#include <new>
#include <iostream>
#include <algorithm>

using namespace std;
using namespace RooFit;
using namespace RooStats;

// // CI -> the confidence interval you want.
//pair<double, double> ConfidenceInterval(float CI, RooRealVar *fnll, RooDataSet *data, RooAbsPdf *pdf);

pair<double, double> CI(float CI, const char *poiname="N_{#Upsilon(3S)}")
{
   RooRealVar *theVar; RooDataSet *data; RooAbsPdf *pdf;
   // Open input file with workspace (generated by rf14_wspacewrite)
   TFile *f = new TFile("fitresult_pbpb_04nov2014.root") ;

   // Retrieve workspace from file
   RooWorkspace* ws = (RooWorkspace*) f->Get("ws");
   theVar = ws->var(poiname);
   pdf = ws->pdf("pdf");
   data =(RooDataSet *) ws->data("data");

   // Print structure of composite p.d.f.
   pdf->Print("t") ;



   //ConfidenceInterval(0.95, n3S, data, pdf);


   ProfileLikelihoodCalculator pl(*data,*pdf,*theVar);
   pl.SetConfidenceLevel(CI); 
   int ci = 100*CI;
   LikelihoodInterval* interval = pl.GetInterval();
   LikelihoodIntervalPlot plot(interval);
   TCanvas c4; c4.cd(); 
   plot.SetRange(50.,0.,250.,3.);
   // plot.Draw();
   TLatex latexCI;
   latexCI.SetNDC();
   latexCI.SetTextSize(0.035);
   latexCI.DrawLatex(0.5,1.-0.05*2,Form("%s %d % C.I.",poiname,ci));
   latexCI.DrawLatex(0.5,1.-0.05*3,Form("Upper limit: %f",interval->UpperLimit(*theVar)));
   latexCI.DrawLatex(0.5,1.-0.05*4,Form("Lower limit: %f",interval->LowerLimit(*theVar)));
   TString intrvlName = theVar->GetTitle();
   // print out the iterval on the Parameter of Interest
   cout <<endl<< CI <<"\% interval on " <<theVar->GetName()<<" is : ["<<
      interval->LowerLimit(*theVar) << ", "<<
      interval->UpperLimit(*theVar) << "] "<<endl;
   pair<double, double> CnfdncIntrvl;
   CnfdncIntrvl.first  = interval->LowerLimit(*theVar);
   CnfdncIntrvl.second = interval->UpperLimit(*theVar);
   c4.SaveAs("ULtest.pdf");

   // Let's try to get a Feldman-Cousins interval
   ModelConfig modelConfig(ws);
   modelConfig.SetPdf(*pdf);
   RooArgSet paramOfInterest(*theVar);
   modelConfig.SetParametersOfInterest(paramOfInterest);
   /////////////////////////////////////////////////////////////
   // Now get the POI for convenience
   // you may want to adjust the range of your POI
   ////////////////////////////////////////////////////////////
   RooRealVar* firstPOI = (RooRealVar*) modelConfig.GetParametersOfInterest()->first();
   // firstPOI->setMin(0.7*max((double) 0.,CnfdncIntrvl.first));
   // firstPOI->setMax(1.3*CnfdncIntrvl.second);
   firstPOI->setMin(80.);
   firstPOI->setMax(100.);

   // create and use the FeldmanCousins tool
   FeldmanCousins fc(*data,modelConfig);
   // fc.SetTestSize(1-CI);
   fc.SetConfidenceLevel(CI); // 95% interval
   fc.AdditionalNToysFactor(0.2); // to speed up the result. Basically N toys = 1000 by default, so with 0.2 it will do 200 toys per test value of the POI.
   //  fc.UseAdaptiveSampling(true); // speed it up a bit, but don't use for expectd limits
   fc.SetNBins(50);
   fc.CreateConfBelt(true); // save the information in the belt for plotting

   /////////////////////////////////////////////
   // Feldman-Cousins is a unified limit by definition
   // but the tool takes care of a few things for us like which values
   // of the nuisance parameters should be used to generate toys.
   // so let's just change the test statistic and realize this is 
   // no longer "Feldman-Cousins" but is a fully frequentist Neyman-Construction.
   //  fc.GetTestStatSampler()->SetTestStatistic(&onesided);
   // ((ToyMCSampler*) fc.GetTestStatSampler())->SetGenerateBinned(true);
   ToyMCSampler*  toymcsampler = (ToyMCSampler*) fc.GetTestStatSampler(); 
   ProfileLikelihoodTestStat* testStat = dynamic_cast<ProfileLikelihoodTestStat*>(toymcsampler->GetTestStatistic());

   // Since this tool needs to throw toy MC the PDF needs to be
   // extended or the tool needs to know how many entries in a dataset
   // per pseudo experiment.  
   // In the 'number counting form' where the entries in the dataset
   // are counts, and not values of discriminating variables, the
   // datasets typically only have one entry and the PDF is not
   // extended.  
   if(!modelConfig.GetPdf()->canBeExtended()){
      if(data->numEntries()==1)     
         fc.FluctuateNumDataEntries(false);
      else
         cout <<"Not sure what to do about this model" <<endl;
   }

   // We can use PROOF to speed things along in parallel
   // ProofConfig pc(*ws, 7, "workers=7",false); 
   ProofConfig pc(*ws, 200,gSystem->GetFromPipe("pod-info -c"),false); 
   if(modelConfig.GetGlobalObservables()){
      cout << "will use global observables for unconditional ensemble"<<endl;
      modelConfig.GetGlobalObservables()->Print();
      toymcsampler->SetGlobalObservables(*modelConfig.GetGlobalObservables());
   }
   toymcsampler->SetProofConfig(&pc);	// enable proof

   // now compute the interval
   ConfInterval* fcint = fc.GetInterval();
   ConfidenceBelt* belt = fc.GetConfidenceBelt();

   // Get Lower and Upper limits from FeldmanCousins with profile construction
   if (fcint != NULL) {
      double fcul = ((PointSetInterval*) fcint)->UpperLimit(*theVar);
      double fcll = ((PointSetInterval*) fcint)->LowerLimit(*theVar);
      cout << "FC lower limit on s = " << fcll << endl;
      cout << "FC upper limit on s = " << fcul << endl;
      TLine* fcllLine = new TLine(fcll, 0, fcll, 1);
      TLine* fculLine = new TLine(fcul, 0, fcul, 1);
      fcllLine->SetLineColor(kRed);
      fculLine->SetLineColor(kRed);
      fcllLine->Draw("same");
      fculLine->Draw("same");
      c4.Update();
   }

   // // Using HypotTestInverter
   // // prepare the calculator
   // RooAbsPdf *bkgPdf = new RooAbsPdf(*pdf,"bkgPdf");
   // HybridCalculatorOriginal myhc(*data, *pdf, bkgPdf,0,0);
   // myhc.SetTestStatistic(2);
   // myhc.SetNumberOfToys(1000);
   // myhc.UseNuisance(false);                            

   // // run the hypothesis-test invertion
   // HypoTestInverterOriginal myInverter(myhc,*theVar);
   // myInverter.SetTestSize(1-CI);
   // myInverter.UseCLs(true);
   // // myInverter.RunFixedScan(5,1,6);
   // // scan for a 95% UL
   // myInverter.RunAutoScan(0,200,myInverter.Size()/2,0.005);  
   // // run an alternative autoscan algorithm 
   // // myInverter.RunAutoScan(1,6,myInverter.Size()/2,0.005,1);  
   // //myInverter.RunOnePoint(3.9);


   // HypoTestInverterResult* results = myInverter.GetInterval();

   // HypoTestInverterPlot myInverterPlot("myInverterPlot","",results);
   // TGraphErrors* gr1 = myInverterPlot.MakePlot();
   // gr1->Draw("ALP");

   // double ulError = results->UpperLimitEstimatedError();

   // double upperLimit = results->UpperLimit();
   // std::cout << "The computed upper limit is: " << upperLimit << std::endl;
   // std::cout << "an estimated error on this upper limit is: " << ulError << std::endl;


   return CnfdncIntrvl;
}


